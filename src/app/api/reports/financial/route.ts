import { NextRequest, NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { auth } from "@/lib/auth"

export async function POST(request: NextRequest) {
  try {
    const session = await auth()
    
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    // Check if user has finance role
    if (!["FINANCE", "CEO", "ADMIN"].includes(session.user.role)) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 })
    }

    // Fetch financial data
    const [batches, contracts, processingRuns, warehouseEntries] = await Promise.all([
      prisma.batch.findMany({
        include: { supplier: true },
        orderBy: { createdAt: "desc" },
      }),
      prisma.contract.findMany({
        orderBy: { createdAt: "desc" },
      }),
      prisma.processingRun.findMany({
        orderBy: { startTime: "desc" },
      }),
      prisma.warehouseEntry.findMany({
        include: {
          batch: {
            include: { supplier: true }
          }
        },
        orderBy: { arrivalTimestamp: "desc" },
      }),
    ])

    // Calculate stats
    const totalPayables = batches.reduce((sum, batch) => sum + batch.purchaseCost, 0)
    const totalReceivables = contracts
      .filter(c => c.approvalStatus === "APPROVED")
      .reduce((sum, c) => sum + (c.quantityKg * (c.pricePerKg || 0)), 0)
    const inventoryValue = batches
      .filter(b => ["AT_WAREHOUSE", "STORED", "PROCESSED", "EXPORT_READY"].includes(b.status))
      .reduce((sum, b) => sum + b.purchaseCost, 0)

    // Generate CSV
    let csv = "Financial Report\n"
    csv += `Generated: ${new Date().toLocaleString()}\n`
    csv += `Generated By: ${session.user.name}\n\n`
    
    csv += "SUMMARY\n"
    csv += "Category,Amount (ETB),Amount (USD),Count\n"
    csv += `Total Payables,${totalPayables.toFixed(2)},-,${batches.length}\n`
    csv += `Total Receivables,-,${totalReceivables.toFixed(2)},${contracts.filter(c => c.approvalStatus === "APPROVED").length}\n`
    csv += `Inventory Value,${inventoryValue.toFixed(2)},-,-\n\n`
    
    csv += "PURCHASE TRANSACTIONS\n"
    csv += "Date,Batch Number,Supplier,Origin,Quantity (kg),Cost (ETB),Status\n"
    batches.forEach(batch => {
      csv += `${new Date(batch.createdAt).toLocaleDateString()},${batch.batchNumber},${batch.supplier?.name || 'Unknown'},${batch.origin},${batch.purchasedQuantityKg},${batch.purchaseCost.toFixed(2)},${batch.status}\n`
    })
    
    csv += "\nCONTRACTS\n"
    csv += "Date,Contract Number,Buyer,Quantity (kg),Price/kg (USD),Total Value (USD),Status\n"
    contracts.forEach(contract => {
      const totalValue = contract.quantityKg * (contract.pricePerKg || 0)
      csv += `${new Date(contract.createdAt).toLocaleDateString()},${contract.contractNumber},${contract.buyer},${contract.quantityKg},${contract.pricePerKg || 0},${totalValue.toFixed(2)},${contract.approvalStatus}\n`
    })
    
    csv += "\nWAREHOUSE ENTRIES\n"
    csv += "Date,Warehouse Number,Batch,Supplier,Weight (kg),Cost (ETB),Location\n"
    warehouseEntries.forEach(entry => {
      const locations = entry.storageLocations && entry.storageLocations.length > 0
        ? entry.storageLocations.join(" | ")
        : "N/A"
      csv += `${new Date(entry.arrivalTimestamp).toLocaleDateString()},${entry.warehouseNumber},${entry.batch.batchNumber},${entry.batch.supplier?.name || 'Unknown'},${entry.arrivalWeightKg},${entry.batch.purchaseCost.toFixed(2)},${locations}\n`
    })

    // Return CSV file
    return new NextResponse(csv, {
      status: 200,
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': `attachment; filename="financial-report-${new Date().toISOString().split('T')[0]}.csv"`,
      },
    })

  } catch (error) {
    console.error("Failed to generate financial report:", error)
    return NextResponse.json(
      { error: "Failed to generate report" },
      { status: 500 }
    )
  }
}




