import { NextRequest, NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { auth } from "@/lib/auth"

export async function POST(request: NextRequest) {
  try {
    const session = await auth()
    
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    // Check if user has finance role
    if (!["FINANCE", "CEO", "ADMIN"].includes(session.user.role)) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 })
    }

    // Fetch supplier and batch data
    const [suppliers, batches] = await Promise.all([
      prisma.supplier.findMany({
        orderBy: { name: "asc" },
      }),
      prisma.batch.findMany({
        include: { supplier: true },
        orderBy: { createdAt: "desc" },
      }),
    ])

    // Group by supplier
    const supplierLedger = suppliers.map(supplier => {
      const supplierBatches = batches.filter(b => b.supplierId === supplier.id)
      const totalPurchased = supplierBatches.reduce((sum, b) => sum + b.purchaseCost, 0)
      const totalQuantity = supplierBatches.reduce((sum, b) => sum + b.purchasedQuantityKg, 0)
      const avgPrice = totalQuantity > 0 ? totalPurchased / totalQuantity : 0
      
      return {
        supplier,
        supplierBatches,
        batchCount: supplierBatches.length,
        totalPurchased,
        totalQuantity,
        avgPrice,
        lastPurchase: supplierBatches[0]?.createdAt || null,
      }
    }).filter(s => s.batchCount > 0)
    .sort((a, b) => b.totalPurchased - a.totalPurchased)

    // Generate CSV
    let csv = "Supplier Ledger Report\n"
    csv += `Generated: ${new Date().toLocaleString()}\n`
    csv += `Generated By: ${session.user.name}\n\n`
    
    csv += "SUPPLIER SUMMARY\n"
    csv += "Supplier,Origin,Contact,Batches,Total Quantity (kg),Total Paid (ETB),Avg Price/kg (ETB),Last Purchase\n"
    
    let grandTotalBatches = 0
    let grandTotalQuantity = 0
    let grandTotalPaid = 0
    
    supplierLedger.forEach(entry => {
      grandTotalBatches += entry.batchCount
      grandTotalQuantity += entry.totalQuantity
      grandTotalPaid += entry.totalPurchased
      
      csv += `${entry.supplier.name},${entry.supplier.origin},${entry.supplier.phone || 'N/A'},${entry.batchCount},${entry.totalQuantity.toFixed(2)},${entry.totalPurchased.toFixed(2)},${entry.avgPrice.toFixed(2)},${entry.lastPurchase ? new Date(entry.lastPurchase).toLocaleDateString() : 'N/A'}\n`
    })
    
    csv += `\nTOTALS,,,${grandTotalBatches},${grandTotalQuantity.toFixed(2)},${grandTotalPaid.toFixed(2)},-,-\n\n`
    
    // Detailed transactions per supplier
    csv += "DETAILED TRANSACTIONS\n\n"
    
    supplierLedger.forEach(entry => {
      csv += `${entry.supplier.name.toUpperCase()}\n`
      csv += "Date,Batch Number,Origin,Quantity (kg),Price/kg (ETB),Total Cost (ETB),Status\n"
      
      entry.supplierBatches.forEach(batch => {
        const pricePerKg = batch.purchasedQuantityKg > 0 ? batch.purchaseCost / batch.purchasedQuantityKg : 0
        csv += `${new Date(batch.createdAt).toLocaleDateString()},${batch.batchNumber},${batch.origin},${batch.purchasedQuantityKg.toFixed(2)},${pricePerKg.toFixed(2)},${batch.purchaseCost.toFixed(2)},${batch.status}\n`
      })
      
      csv += `Subtotal for ${entry.supplier.name},,,${entry.totalQuantity.toFixed(2)},,${entry.totalPurchased.toFixed(2)},\n\n`
    })

    // Return CSV file
    return new NextResponse(csv, {
      status: 200,
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': `attachment; filename="supplier-ledger-${new Date().toISOString().split('T')[0]}.csv"`,
      },
    })

  } catch (error) {
    console.error("Failed to generate supplier ledger:", error)
    return NextResponse.json(
      { error: "Failed to generate report" },
      { status: 500 }
    )
  }
}




